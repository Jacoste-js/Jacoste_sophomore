https://school.programmers.co.kr/learn/courses/30/lessons/169198

jihyukim
```js
function solution(m, n, startX, startY, balls) {
    return balls.map((el) => {
        const [x, y] = el;
        const wall = {};

        wall.l = Math.pow(startX + x, 2) + Math.pow(Math.abs(y - startY), 2)
        wall.r = Math.pow(m * 2 - startX - x, 2) + Math.pow(Math.abs(y - startY), 2)
        wall.b = Math.pow(startY + y, 2) + Math.pow(Math.abs(x - startX), 2);
        wall.t = Math.pow(n * 2 - startY - y, 2) + Math.pow(Math.abs(x - startX), 2);
        if (startY === y && startX > x) delete wall.l;
        if (startY === y && startX < x) delete wall.r;
        if (startX === x && startY > y) delete wall.b;
        if (startX === x && startY < y) delete wall.t;

        return Math.min(...Object.values(wall));
    })
}
```
jabae
```js
// code
```
daekim
```js
// code
```
jiyokim
```js
//code
```
rjeong
```js
function solution(m, n, startX, startY, balls) {
  const answer = [];

  for (const ball of balls) {
    const distances = [];

    if (startX !== ball[0]) {
      distances.push((startX - ball[0]) ** 2 + (-startY - ball[1]) ** 2);
      distances.push(
        (startX - ball[0]) ** 2 + (startY + (n - startY) * 2 - ball[1]) ** 2
      );
    }
    if (startY !== ball[1]) {
      distances.push((-startX - ball[0]) ** 2 + (startY - ball[1]) ** 2);
      distances.push(
        (startX + (m - startX) * 2 - ball[0]) ** 2 + (startY - ball[1]) ** 2
      );
    }
    if (startX === ball[0]) {
      if (startY < ball[1]) distances.push((startY + ball[1]) ** 2);
      if (startY > ball[1]) distances.push((n - startY + n - ball[1]) ** 2);
    }
    if (startY === ball[1]) {
      if (startX < ball[0]) distances.push((startX + ball[0]) ** 2);
      if (startX > ball[0]) distances.push((m - startX + m - ball[0]) ** 2);
    }
    answer.push(Math.min(...distances));
  }

  return answer;
}

```
